
#Обеспечивает доступ в веб
# является оболочкой на веб сервером webrick
# имеет 4 точки входа (т.е. адреса)
# - login.html --- страница содержащая окно для логина/пароля
# - login.cgi  --- для ответор на запросы в формате json для логинивания
# - im.html    --- страница содержащая  клиент
# - im.cgi     ---- для ответов на запросы в формате джейсон для клиента, т.е. сообщения типо отправить сообщение, добавить в контакт лист и т.д.
#
#содержит в себе  Parser
class WebServer
	#Создание сервера, здесь создаются 4 точки монтирования, в к которым прикрепляются обработчики запросов
	def initialize
	end
	#Старт сервера
	def start
	end
	#Приостановка сервера
	def stop
	end
	#Выключение сервера
	def shutdown
	end
	@parser
end


=begin
Notes:
В точке login.cgi должно быть проверка корректности жида и пасса, путем попытки законектится
если норм, создание session_id в классе Auth, высылка кукисов, добавление clientManger, при этом полная инициализация клиента, а внутри него jabberClienta'a
если нет, то клиент посылается.

В точке im.cgi,приходят/уходят запросы/ответы в формате json, потом они направлются на выходе которого parsedInfo (объект класса ParsedInfo),
потом идет проверка залогинености юзверя
если залогинен, то его запрос отправляется клиенту, который находиться в клиент манагере, клиент обрабатывает запрос и возращает ответ, который отправляется в парсер, на выходе теперь джейос, который и отправляется клиенту

login.html и im.html --- это просто странички, которые отдаются клиенту.
=end

#Обеспечивает обработку (распарсивание) JSON формата, который посупает (должен поступать) в запросе к веб-серверу
#Возвращает объект типа ParsedInfo (распарсенная информация)
#Работает и в обратную сторону, т.е. по информации возращает JSON-строку, которая отдается клиентну веб-сервером.
#Внутри находиться JSON-парсер (какая-то его реализация).
class Parser
	#ctor
	def initialize
	end
	def parseFromLogin(a_request)
	end
	def parseFromIm(a_request)
	end
	def toJsonForLogin(a_parsedInfo)
	end
	def toJsonForIm(a_parsedInfo)
	end
end

#Хранит информацию запроса/ответа в нормальной, удобной для использования(не текст, а нормальные переменные)
#Во внутреннем формате в виде стандартых типов ruby, массивы и хеши
class ParsedInfo
	#ctor
	def initialize()
	end
	#Получить session_id из распарсенной инфы
	def sessionId
	end
	#Записать данные
	def data=(a_data)
	#Получить данные (в формате стандартных типов руби)
	def data
	end
end

#Хранит и управляет всеми клиентами
#Внутри есть хеш (ключ - сторока хранящая session_id, значение - объект типа Client), хранящий всех клиентов.
#Те кто находятся в этом хеше --- активные клиенты, не активные клиенты (долго не проявлявшие активность) из него удаляются
#Есть возможность добавлять/удалять клиентов, а так же чистить неактивных клиентов.
#Дает доступ к контретному клиенту по строке, содержащей session_id
#Является синглетоном
#Уникальные session_id генерятся в нем же.
class ClientManager
	def addClient(a_client)
	end
	def delClient(a_sessionId)
	end
	#Возращает клиента по id
	def [](a_sessionId)
	end
	def clear
	end
	def delNoActiveClients
	end
	#Возращает строку, представляющую новый уникальный sessin_id
	def ClientManager.getNewSessionId
	end
	@clients
end

#Хранит информацию об отдельно взятом клиенте(всмысле юзера, а не джаббер клиента)
#В нем хранится джаббер клиент(jabberClient)  (объект типа JabberClient), auth (объект типа AuthInfo)
#Так же в нем производится обработка parsedInfo (там производятся все действия запрошенные пользователем, а так же отдаются события произошедшие между вызовами, такие как входящие сообщения ) 
class Client
	#Cоздание клиента. Должно учитывать сервер по умолчанию из jid'a, и порт по умолчанию (5222)
	def initilalize(a_jid, a_password, a_server, a_port)
	end
	#Тоже создание клиента, только в качестве параметра передается хеш, для удобства
	def initialize(a_params)
	end
	#Выполнение запроса клиента
	#Возвращает объект типа ParsedInfo, в котором хранится информация которую надо отправить клиенту.
	#Ему передается объект типа parsedInfo в котором содержится распарсенный запрос клиента
	#Сам метод взаимодействует через объект executerRequets.
	def runRequet(a_parsedInfo)
	end
	
	#Возращает @jabberClient
	def jabberClient
	end

	#Возращает @auth
	def auth
	end
	
	#Попытка подключиться к джаббер-серверу, возращает true если получилось и false если нет.
	#Если возращает true, то clientManager должен добавить его в клиенты.
	def tryConnect
	end
	
	@jabberClient
	@auth
	@@executerRequest #исполнитель алгоритма, т.е. алгоритм выполнения инкапсулирован в объект класс
end

##
#Хранить авторизационные данные клиента, пока только время последней активности, с помощью которого можно найти неактивных клиентов, должна обновлятся с каждым запросом
class AuthInfo
	def lastActivity
	end
	def updateLastActivity
	end
	@lastActivity
end

##
#Оболочка над библиотекой xmpp
#Содержит в себе ростер, джаббер клиент из библиотеки, мук клиент и т.д.
#Содержит все обработчики входящих сообщений/действий, а также очередь где они сохраняются
#Содержит базовый набор методов для отправки сообщений и действий с ростером
#потом он будет расширяться
#внешний интерфейс не должен зависить от библиотеки xmpp, через этот интерфейс будет взаимодействовать метод runRequest в классе Client
class JabberClient
	##
	#ctor
	#Не конектится к серверу, коннект обеспечивает метод connect
	#a_jid:: [String]
	#a_pass:: [String]
	#a_server:: [String]
	#a_port:: [Integer]
	def initialize(a_jid, a_pass, a_server, a_port)
	end
	
	##
	#Попытка конектится к серверу,
	#если удачно, то возвращает true, ""
	#если нет, то возвращает false,"текст ошибки"
	def connect
	end
	
	##
	#Полная инициализация джаббер клиента, т.е. прикрипление обработчиков событий
	def fullInit
	end


	##
	#Завершение соединения
	def closeConnection
	end
	
	##
	#Установка статуса
	#a_show тип статуса, возможные значения ={ :chat => 4, nil/:online => 3, :dnd => 2, :away => 1, :xa => 0, :unavailable => -1, :error => -2 }
	#a_status - текст статуса,
	#a_priority - приоритет текущего подключения
	#Статус устанавливается немедленно
	def setStatus(a_show=nil, a_status=nil, a_priority=nil)
	end

	##
	#Послать сообщение
	#a_to:: [String] кому
	#a_type:: [Symbol] тип сообщения, возможные значения:   :chat, :error, :groupchat, :headline, :normal
	#a_text:: [String] текст сообщения
	#a_subject:: [String] тема сообщения, используется в :normal сообщениях, они как почта, поэтому и с темой 
	def sendMessage(a_to,a_text,a_type,a_subject=nil)
	end

	##
	#Послать чатовое сообщение
	#Синтаксический сахар для sendMessage(,,:chat)
	#a_to:: [String] кому
	#a_text:: [String] текст сообщения
	def sendChatMessage(a_to, a_text)
	end

	##
	#Пройтись по всем входящим сообщениям
	#Очередь сообщений после вызова метода очищается!!!
	#Методу нужно передавать замыкание, обрабатывающее сообщения
	#a_closure:: [CodeBlock]
	#Замыканию передаются 	from:: [String] jid того, кто передал сообщение
	#			type:: [Symbol] тип сообщения
	#			text:: [String] текст сообщения	
	def eachIncomingMessages(&a_closure)
	end

	##
	#Пройтись по контактам в ростере
	#Методу нужно передавать замыкание
	#a_closure:: [CodeBlock]
	#Замыканию передаются 	group:: [String] or nil	имя группы в которой находится контакт
	#			jid:: [String]		jid контакта
	#			name:: [String] or nil 	имя контакта, под которым он записан в ростере
	def eachJIDinRoster(&a_closure)
	end
	
	#Исправить
	#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
	##
	#Пройтись по всем изменениям в статусе
	#Note: сначало приходит сразу много сообщений.
	#Методу нужно передавать замыкание
	#a_closure:: [CodeBlock]
	#Замыканию передаются	jid:: [String]			jid сменившего статус	
	#			type:: [Symbol]			тип статуса, аналогичен типу в setStatus
	#			status:: [String] or nil	текст статусного сообщения, его может и не быть 	
	def eachPresences(&a_closure)
	end


end

#Класс, который реализует алгоритм выполнения запроса клиента.
#Создан чтобы вынести алгоритм из класса клиента, в случае смены/добавления новых видов запросов
#меняется это класс или пишется другой, с таким же интерфейсом.
class ExecuterRequest
	#Выполнение запроса
	#a_request объект типа ParsedInfo, содержащий запрос
	#a_jabberClient объект над которым будут выполнятся действия.
	def run(a_request,a_jabberClient)
	end
end

#note:Используемая библиотека xmpp xmmp4r

